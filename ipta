#!/usr/bin/perl -w

use strict;
use warnings FATAL => qw(all);

main();

###########################

sub main
{
my %cfg = handle_args(@ARGV);

}

sub handle_args(@)
{	# More complex than my normal handle_args; 
	# Here we determine if the commandline is ipta-ish or
	# iptables-ish, and if it's the latter, we'll just exec iptables.
	# If it's the former, we want to do a partial parsing of the arguments
	# but preserve the ordering so we don't need to fully understand and re-pack
	# arguments for iptables.
	# We'll try to keep things simple by having commands that pass blobs of config to
	# iptables do the ipta args first.
my @args = @_;


}

##########
# Dispatch functions

sub dispatch_remind
{
print <<EOREMIND;
(From network Adapter, input interface visible)
PREROUTING:raw
(+session tracking)
PREROUTING:mangle
PREROUTING:nat
(routing, to INPUT or FORWARD)

(INPUT, input interface visible)
INPUT:mangle
INPUT:filter

(FORWARD, input and output interface visible)
FORWARD:mangle
FORWARD:filter
(To POSTROUTING)

(From Software, output interface visible)
OUTPUT:raw
OUTPUT:mangle
OUTPUT:nat
OUTPUT:filter
(routing, to POSTROUTING)

(POSTOUTING, output interface visible)
POSTROUTING:mangle
POSTROUTING:nat

EOREMIND
exit(0);
}

sub dispatch_list
{
}

sub dispatch_add
{
}

sub dispatch_remove
{
}

sub dispatch_flush
{
}

sub dispatch_lint
{
}

sub usage
{

}

##################

sub directed_iptables
{	# Exists to get tabular data for a particular chain-table permutation.
	# TODO: Make this return data in a structured, regular format
my ($chain, $table) = @_;

my $tablepart = "";
if(defined $table)
	{$tablepart .= "-t $table";}
my $ret = docmd("iptables -L $chain $tablepart -v --line-numbers"); # Do I want a -n ?
return $ret; # XXX May want to process this first, maybe into a list? Maybe return a listref?
}

##################
# General utilities

sub docmd($)
{ # TODO: Import this from my perl library

}
