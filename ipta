#!/usr/bin/perl -w

use strict;
use warnings FATAL => qw(all);

main();

###########################

sub main
{
my %cfg = handle_args(@ARGV);

if($cfg{cmd} eq 'remind')
	{
	dispatch_remind();
	}
elsif($cfg{cmd} eq 'list')
	{

	}
elsif($cfg{cmd} eq 'add')
	{

	}
elsif($cfg{cmd} eq 'remove')
	{

	}
elsif($cfg{cmd} eq 'flush')
	{

	}
elsif($cfg{cmd} eq 'lint')
	{

	}
}

sub handle_args(@)
{	# More complex than my normal handle_args; 
	# Here we determine if the commandline is ipta-ish or
	# iptables-ish, and if it's the latter, we'll just exec iptables.
	# If it's the former, we want to do a partial parsing of the arguments
	# but preserve the ordering so we don't need to fully understand and re-pack
	# arguments for iptables.
	# We'll try to keep things simple by having commands that pass blobs of config to
	# iptables do the ipta args first.
my @args = @_;
my %ret;

if(! @args)
	{usage();}
if($args[0] =~ /^--help/)
	{usage();}
elsif($args[0] =~ /^--version/)
	{version();exit(0);}
elsif($args[0] =~ /^-/) # IPTables syntax, so just invoke iptables
	{exec("iptables", @args);}
else
	{
	$ret{cmd} = $args[0];
	# TODO ... parse other arguments
	}
return %ret;
}

##########
# Dispatch functions

sub dispatch_remind
{
print <<EOREMIND;
(From network Adapter, input interface visible)
PREROUTING:raw /* Can disable tracking with -j NOTRACK */
PREROUTING:mangle /* Can alter TOS, TTL or mark */
PREROUTING:nat /* Can do DNAT, SNAT, or REDIRECT */
(Packets are routed, sent to INPUT or FORWARD chains)

(INPUT, input interface visible)
INPUT:mangle /* Mainly used to mark packets for filtering */
INPUT:filter /* Can drop or reject packets */
(Packets handled by local system)

(FORWARD, input and output interface visible)
FORWARD:mangle /* Can alter TOS, TTL, or mark */
FORWARD:filter /* Can drop or reject packets */
(Packets enter POSTROUTING chain)

(From Software, output interface visible)
OUTPUT:raw /* before session tracking, -m state permitted after here */
OUTPUT:mangle /* Can alter TOS, TTL, or mark */
OUTPUT:nat /* Can DNAT, SNAT, or REDIRECT */
OUTPUT:filter /* Can drop or reject packets */
(Packets are routed, sent to POSTROUTING chain)

(POSTOUTING, output interface visible, for both forwarded and output packets)
POSTROUTING:mangle /* Can alter TOS, TTL, or mark */
POSTROUTING:nat /* Can do SNAT */
(Packets sent out on relevant interface)

EOREMIND
exit(0);
}

sub dispatch_list
{
}

sub dispatch_add
{
}

sub dispatch_remove
{
}

sub dispatch_flush
{
}

sub dispatch_lint
{
}

sub usage
{

}

##################
# iptables stuff

sub directed_iptables
{	# Exists to get tabular data for a particular chain-table permutation.
	# TODO: Make this return data in a structured, regular format
my ($chain, $table) = @_;

my $tablepart = "";
if(defined $table)
	{$tablepart .= "-t $table";}
my $ret = docmd("iptables -L $chain $tablepart -v --line-numbers"); # Do I want a -n ?
return $ret; # XXX May want to process this first, maybe into a list? Maybe return a listref?
}

sub load_iptables
{ # Load all the standard tablechains, and if we can, the nonstandard ones
my %tabs;

$tabs{prerouting}{raw}		= ipt_parse(directed_iptables('prerouting',	'raw'	));
$tabs{prerouting}{mangle}	= ipt_parse(directed_iptables('prerouting',	'mangle'));
$tabs{prerouting}{nat}		= ipt_parse(directed_iptables('prerouting',	'nat'	));

$tabs{input}{mangle}		= ipt_parse(directed_iptables('input',		'mangle'));
$tabs{input}{filter}		= ipt_parse(directed_iptables('input',		'filter'));

$tabs{forward}{mangle}		= ipt_parse(directed_iptables('forward',	'mangle'));
$tabs{forward}{filter}		= ipt_parse(directed_iptables('forward',	'filter'));

$tabs{output}{raw}		= ipt_parse(directed_iptables('output',		'raw'	));
$tabs{output}{mangle}		= ipt_parse(directed_iptables('output',		'mangle'));
$tabs{output}{nat}		= ipt_parse(directed_iptables('output',		'nat'	));
$tabs{output}{filter}		= ipt_parse(directed_iptables('output',		'filter'));

$tabs{postrouting}{mangle}	= ipt_parse(directed_iptables('postrouting',	'mangle'));
$tabs{postrouting}{nat}		= ipt_parse(directed_iptables('postrouting',	'nat'	));
# TODO: How to detect custom chains?
return \%tabs;
}

sub ipt_parse($)
{	# Iterate over the lines that directed_iptables gives us and gives us a list of
	# the rules in that table in structured form. iptables numbering is 1-based, so
	# we'll need to be careful in later processing to take that into consideration so
	# our list or lint or positioned adding functions don't confuse people.
my ($textglob) = @_;
my @rules;
open(RULES, \$textglob) || die "Failed to read iptables result data\n";
while(<RULES>)
	{
	# TODO
	# 1) Skip headers
	# 2) Create a hash to represent this line's directives
	# 3) Step through the iptables listing to try to grab raw directives
	#	and key-value pairs, packing them into the hash
	# 4) At the end of the line, append this hash into @rules
	}
close(RULES);
return @rules;
}

##################
# General utilities

sub docmd($)
{ # TODO: Import this from my perl library

}

sub version()
{

}

